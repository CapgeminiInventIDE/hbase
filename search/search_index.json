{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation \u00a4 pip install hbase Usage \u00a4 Build an instance to interact with the web service, check out the HBase client reference for a full list of available methods. from hbase import HBase hbase = HBase ( base_url = \"http://localhost:8000\" ) Then, executing an HTTP request is as simply as invoking a method. # Get all rows using the wildcard, or supply exact row_id for single row hbase . get_row ( table = \"example_table\" , row_id = \"*\" ) The returned object is a friendly Pydantic model which will automatically decode the response from base64: CellSet ( Row = [ Row ( key = \"decoded_key\" , Cell = [ Cell ( column = \"decoded_column\" , timestamp = 39082034 , value = \"decoded_value\" ), ... ] ), ... ] ) Similarly you can perform other CRUD operations on HBase, such as inserting a row, note that the data will automatically be encoded into base64 for you free of charge! hbase . insert_rows ( test_table_name , rows = { \"row-1\" : { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" }, \"row-2\" : { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" } } ) hbase . insert_row ( test_table_name , row_id = \"row-3\" , column_data = { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" } ) For sending non-blocking requests, HBase uses Uplink, which comes with support for aiohttp and twisted.","title":"Getting Started"},{"location":"#installation","text":"pip install hbase","title":"Installation"},{"location":"#usage","text":"Build an instance to interact with the web service, check out the HBase client reference for a full list of available methods. from hbase import HBase hbase = HBase ( base_url = \"http://localhost:8000\" ) Then, executing an HTTP request is as simply as invoking a method. # Get all rows using the wildcard, or supply exact row_id for single row hbase . get_row ( table = \"example_table\" , row_id = \"*\" ) The returned object is a friendly Pydantic model which will automatically decode the response from base64: CellSet ( Row = [ Row ( key = \"decoded_key\" , Cell = [ Cell ( column = \"decoded_column\" , timestamp = 39082034 , value = \"decoded_value\" ), ... ] ), ... ] ) Similarly you can perform other CRUD operations on HBase, such as inserting a row, note that the data will automatically be encoded into base64 for you free of charge! hbase . insert_rows ( test_table_name , rows = { \"row-1\" : { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" }, \"row-2\" : { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" } } ) hbase . insert_row ( test_table_name , row_id = \"row-3\" , column_data = { \"col1\" : \"dat1\" , \"col2\" : \"dat2\" } ) For sending non-blocking requests, HBase uses Uplink, which comes with support for aiohttp and twisted.","title":"Usage"},{"location":"alternatives/","text":"Coming soon ... \u00a4","title":"Alternatives"},{"location":"alternatives/#coming-soon","text":"","title":"Coming soon ..."},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: docker build . -t capgeminiinventide/hbase docker run -it capgeminiinventide/hbase bash That's it! You now have the dependencies installed. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: Ensure to run all of the pre commit hooks from the root directory Follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Development - Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: docker build . -t capgeminiinventide/hbase docker run -it capgeminiinventide/hbase bash That's it! You now have the dependencies installed.","title":"Environment setup"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: Ensure to run all of the pre commit hooks from the root directory Follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"features/","text":"Coming soon ... \u00a4","title":"Features"},{"location":"features/#coming-soon","text":"","title":"Coming soon ..."},{"location":"release-notes/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.2.0 - Date: 28/08/2021 \u00a4 Pre-release 0.1.3 - Date: 20/08/2021 \u00a4 Pre-release","title":"Release Notes"},{"location":"release-notes/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"release-notes/#020-date-28082021","text":"Pre-release","title":"0.2.0 - Date: 28/08/2021"},{"location":"release-notes/#013-date-20082021","text":"Pre-release","title":"0.1.3 - Date: 20/08/2021"},{"location":"reference/client/","text":"HBase - HBase \u00a4 \u00a4 A Python Client for the HBase API. Build using the following references: HBase REST API docs - 1.2 Notes Built to: Server='jetty/9.3.27.v20190418' Jersey='' OS='Linux 5.10.47-linuxkit amd64' REST='0.0.3' JVM='Oracle Corporation 1.8.0_302-25.302-b08' StorageClusterVersion='2.2.2' create_namespace ( self , namespace ) \u00a4 Creates a namespace in HBase, this operation is idempotent Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f8326e80> (Type: string) The name of the namespace you want to create required Returns: Type Description Response requests.models.Response: The response for the user to handle and check the response code Source code in hbase/client.py @headers ({ \"Accept\" : \"application/json\" }) @post ( \"namespaces/ {namespace} \" ) def create_namespace ( self , namespace : Path ( type = str )) -> requests . models . Response : \"\"\"Creates a namespace in HBase, this operation is idempotent Args: namespace (str): (Type: string) The name of the namespace you want to create Returns: requests.models.Response: The response for the user to handle and check the response code \"\"\" create_scanner ( self , table , start_row = None , end_row = None , columns = [], batch_size = None , start_time = None , end_time = None ) \u00a4 Creates a scanner and returns the scanner id Parameters: Name Type Description Default table str The table for which you want to get the data from required row_prefix str The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to \"\". required start_row Optional[str] The start row for the scan. Defaults to None. None end_row Optional[str] The end row for the scan. Defaults to None. None columns List[str] The columns to scan. Defaults to None. [] batch_size Optional[int] To limit the maximum number of values returned for each call to next().. Defaults to None. None start_time Optional[int] To only retrieve columns within a specific range of version timestamps. Defaults to None. None end_time Optional[int] To only retrieve columns within a specific range of version timestamps. Defaults to None. None Exceptions: Type Description ScannerCreationFailed Raised when the scanner has failed to be created (request headers.Location is None) Returns: Type Description str str: The scanner ID Notes More on start row, end row and limit parameters. If start row, end row and limit not specified, then the whole table will be scanned. If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. If only limit parameter is specified, then the scan operation will return N rows from the start of the table. If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. Source code in hbase/client.py def create_scanner ( self , table : str , start_row : Optional [ str ] = None , end_row : Optional [ str ] = None , columns : List [ str ] = [], batch_size : Optional [ int ] = None , start_time : Optional [ int ] = None , end_time : Optional [ int ] = None , ) -> str : \"\"\"Creates a scanner and returns the scanner id Args: table (str): The table for which you want to get the data from row_prefix (str, optional): The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to \"\". start_row (str, optional): The start row for the scan. Defaults to None. end_row (str, optional): The end row for the scan. Defaults to None. columns (List[str], optional): The columns to scan. Defaults to None. batch_size (int, optional): To limit the maximum number of values returned for each call to next().. Defaults to None. start_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. end_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. Raises: ScannerCreationFailed: Raised when the scanner has failed to be created (request headers.Location is None) Returns: str: The scanner ID Notes: More on start row, end row and limit parameters. - If start row, end row and limit not specified, then the whole table will be scanned. - If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. - If only limit parameter is specified, then the scan operation will return N rows from the start of the table. - If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. - If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. \"\"\" add_if = lambda key , val : f ' { key } =\" { val } \" ' if val is not None else \"\" xml = f \"\"\"<Scanner { add_if ( \"batch\" , batch_size ) }{ add_if ( \"startRow\" , to_base64 ( start_row )) }{ add_if ( \"endRow\" , to_base64 ( end_row )) }{ add_if ( \"columns\" , to_base64 ( \",\" . join ( columns ))) }{ add_if ( \"startTime\" , start_time ) }{ add_if ( \"endTime\" , end_time ) } />\"\"\" resp = self . __create_scanner ( table , xml ) . headers . get ( \"Location\" ) if resp is None : raise ScannerCreationFailed ( \"Unable to create Scanner\" ) return resp . split ( \"/\" )[ - 1 ] create_table ( self , table , column_names ) \u00a4 Utility function for creating a table - HBase REST API only accepts XML for this request Parameters: Name Type Description Default table str The name of the table you wish to create required column_names List[str] The list of the table column names required Returns: Type Description Response requests.models.Response: The HTTP response from creating the table for the user to check Source code in hbase/client.py def create_table ( self , table : str , column_names : List [ str ]) -> requests . models . Response : \"\"\"Utility function for creating a table - HBase REST API only accepts XML for this request Args: table (str): The name of the table you wish to create column_names (List[str]): The list of the table column names Returns: requests.models.Response: The HTTP response from creating the table for the user to check \"\"\" xml_packet = f \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\" { table } \"> { '' . join ( f '<ColumnSchema name=\" { col } \" />' for col in column_names ) } </TableSchema>\"\"\" return self . __create_table ( table , xml_packet ) delete_cell ( self , table , row_id , column ) \u00a4 Deletes a entire cell from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832bac8> The name of the table from which the cell belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832ba90> The name of the row_id from which the cell belongs that you wish to delete. required column <uplink.arguments.Path object at 0x7f52f832bb70> The name of the column from which the cell belongs that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the cell for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} / {column} \" ) def delete_cell ( self , table : Path ( type = str ), row_id : Path ( type = str ), column : Path ( type = str ) ) -> requests . models . Response : \"\"\"Deletes a entire cell from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the cell belongs that you wish to delete. row_id (str): The name of the row_id from which the cell belongs that you wish to delete. column (str): The name of the column from which the cell belongs that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the cell for the user to check \"\"\" delete_cell_with_timestamp ( self , table , row_id , column , timestamp ) \u00a4 Deletes a entire cell with the given timestamp from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832bd30> The name of the table from which the cell belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832bc88> The name of the row_id from which the cell belongs that you wish to delete. required column <uplink.arguments.Path object at 0x7f52f832bda0> The name of the column from which the cell belongs that you wish to delete. required timestamp <uplink.arguments.Path object at 0x7f52f832bcc0> The timestamp from which the cell belongs that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the cell for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} / {column} / {timestamp} \" ) def delete_cell_with_timestamp ( self , table : Path ( type = str ), row_id : Path ( type = str ), column : Path ( type = str ), timestamp : Path ( type = int ) ) -> requests . models . Response : \"\"\"Deletes a entire cell with the given timestamp from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the cell belongs that you wish to delete. row_id (str): The name of the row_id from which the cell belongs that you wish to delete. column (str): The name of the column from which the cell belongs that you wish to delete. timestamp (int): The timestamp from which the cell belongs that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the cell for the user to check \"\"\" delete_namespace ( self , namespace ) \u00a4 Deletes a table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f832b7b8> The name of the namespace you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the namespace for the user to check Source code in hbase/client.py @delete ( \"namespaces/ {namespace} \" ) def delete_namespace ( self , namespace : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a table, if successful, returns HTTP 200 status. Args: namespace (str): The name of the namespace you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the namespace for the user to check \"\"\" delete_row ( self , table , row_id ) \u00a4 Deletes a entire row from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832b940> The name of the table from which the row belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832b978> The name of the row_id that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the row for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} \" ) def delete_row ( self , table : Path ( type = str ), row_id : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a entire row from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the row belongs that you wish to delete. row_id (str): The name of the row_id that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the row for the user to check \"\"\" delete_scanner ( self , table , scanner_id ) \u00a4 Deletes resources associated with the scanner. Note: This is an optional action. Scanners will expire after some globally configurable interval has elapsed with no activity on the scanner. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832be80> The table name that the scanner is attached to. required scanner_id <uplink.arguments.Path object at 0x7f52f832bf98> The scanner id gathered from HBase.create_scanner(). required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the scanner for the user to check Source code in hbase/client.py @delete ( \" {table} /scanner/ {scanner_id} \" ) def delete_scanner ( self , table : Path ( type = str ), scanner_id : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes resources associated with the scanner. Note: This is an optional action. Scanners will expire after some globally configurable interval has elapsed with no activity on the scanner. Args: table (str): The table name that the scanner is attached to. scanner_id (str): The scanner id gathered from HBase.create_scanner(). Returns: requests.models.Response: The HTTP response from deleting the scanner for the user to check \"\"\" delete_table ( self , table ) \u00a4 Deletes a table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832b630> The name of the table you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the table for the user to check Source code in hbase/client.py @delete ( \" {table} /schema\" ) def delete_table ( self , table : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a table, if successful, returns HTTP 200 status. Args: table (str): The name of the table you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the table for the user to check \"\"\" get_cell ( self , table , row_id , column , num_versions = None ) \u00a4 Retrieves single cell, use column={column_name}:{qualifier} for qualifiers Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f83262e8> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f8326320> The row ID for which you want to get the data from. Use * for multiple rows. required column <uplink.arguments.Path object at 0x7f52f8326358> The column name you want to get data from required num_versions <uplink.arguments.Query object at 0x7f52f8326390> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and column Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} / {column} \" ) def get_cell ( self , table : Path ( type = str ), # noqa: F821 row_id : Path ( type = str ), # noqa: F821 column : Path ( type = str ), # noqa: F821 num_versions : Query ( \"v\" , type = int ) = None , # noqa: F821 ) -> CellSet : # noqa: F821 \"\"\"Retrieves single cell, use column={column_name}:{qualifier} for qualifiers Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column (str): The column name you want to get data from num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and column Returns: CellSet: The data from the requested HBase Cell/s \"\"\" get_cell_with_timestamp ( self , table , row_id , column , timestamp , num_versions = None ) \u00a4 Retrieves single cell with the given timestamp, use column={column_name}:{qualifier} for qualifiers Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f83265c0> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f83264e0> The row ID for which you want to get the data from. Use * for multiple rows. required column <uplink.arguments.Path object at 0x7f52f83265f8> The column name you want to get data from required timestamp <uplink.arguments.Path object at 0x7f52f8326630> The given timestamp to filter by required num_versions <uplink.arguments.Query object at 0x7f52f8326668> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and column Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} / {column} / {timestamp} \" ) def get_cell_with_timestamp ( self , table : Path ( type = str ), # noqa: F821 row_id : Path ( type = str ), # noqa: F821 column : Path ( type = str ), # noqa: F821 timestamp : Path ( type = int ), # noqa: F821 num_versions : Query ( \"v\" , type = int ) = None , # noqa: F821 ) -> CellSet : \"\"\"Retrieves single cell with the given timestamp, use column={column_name}:{qualifier} for qualifiers Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column (str): The column name you want to get data from timestamp (int): The given timestamp to filter by num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and column Returns: CellSet: The data from the requested HBase Cell/s \"\"\" get_namespaces ( self ) \u00a4 Lists all namespaces Returns: Type Description NameSpaces NameSpaces: All of the namespaces for the HBase instance Source code in hbase/client.py @returns . json ( NameSpaces ) @headers ({ \"Accept\" : \"application/json\" }) @get ( \"namespaces\" ) def get_namespaces ( self ) -> NameSpaces : \"\"\"Lists all namespaces Returns: NameSpaces: All of the namespaces for the HBase instance \"\"\" get_next_scanner ( self , table , scanner_id ) \u00a4 Returns the values of the next cells found by the scanner, up to the configured batch amount. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326828> The table for which you want to get the data from required scanner_id <uplink.arguments.Path object at 0x7f52f8326898> The scanner id gathered from HBase.create_scanner() required Exceptions: Type Description ScannerCreationFailed If the scanner fails Returns: Type Description CellSet CellSet: The next round of data from the requested HBase Cell/s using the scanner Source code in hbase/client.py @_raise_for_scanner @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /scanner/ {scanner_id} \" ) def get_next_scanner ( self , table : Path ( type = str ), scanner_id : Path ( type = str )) -> CellSet : \"\"\"Returns the values of the next cells found by the scanner, up to the configured batch amount. Args: table (str): The table for which you want to get the data from scanner_id (str): The scanner id gathered from HBase.create_scanner() Raises: ScannerCreationFailed: If the scanner fails Returns: CellSet: The next round of data from the requested HBase Cell/s using the scanner \"\"\" get_row ( self , table , row_id , num_versions = None ) \u00a4 Retrieves single row, or multiple rows using * Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326080> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f83260b8> The row ID for which you want to get the data from. Use * for multiple rows. required num_versions <uplink.arguments.Query object at 0x7f52f83260f0> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table and row_id Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} \" ) def get_row ( self , table : Path ( type = str ), row_id : Path ( type = str ), num_versions : Query ( \"v\" , type = int ) = None # noqa: F821 ) -> CellSet : # noqa: F821 \"\"\"Retrieves single row, or multiple rows using * Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table and row_id Returns: CellSet: The data from the requested HBase Cell/s \"\"\" get_row_with_multiple_columns ( self , table , row_id , columns = [], start_time = None , end_time = None , num_versions = None ) \u00a4 Retrieves one or more cells from a full row, or one or more specified columns in the row, with optional filtering via timestamp, and an optional restriction on the maximum number of versions to return. Parameters: Name Type Description Default table str The table for which you want to get the data from required row_id str The row ID for which you want to get the data from. Use * for multiple rows. required columns List[str] The column name you want to get data from. Defaults to []. [] start_time Optional[int] The given start timestamp to filter by. Defaults to None. None end_time Optional[int] The given end timestamp to filter by. Defaults to None. None num_versions Optional[int] The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and filters Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py def get_row_with_multiple_columns ( self , table : str , row_id : str , columns : List [ str ] = [], start_time : Optional [ int ] = None , end_time : Optional [ int ] = None , num_versions : Optional [ int ] = None , ) -> CellSet : \"\"\"Retrieves one or more cells from a full row, or one or more specified columns in the row, with optional filtering via timestamp, and an optional restriction on the maximum number of versions to return. Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. columns (List[str], optional): The column name you want to get data from. Defaults to []. start_time (Optional[int], optional): The given start timestamp to filter by. Defaults to None. end_time (Optional[int], optional): The given end timestamp to filter by. Defaults to None. num_versions (Optional[int], optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and filters Returns: CellSet: The data from the requested HBase Cell/s \"\"\" return self . stateless_scanner ( table , row_prefix = row_id , columns = columns , start_time = start_time , end_time = end_time , max_versions = num_versions , ) get_schema ( self , table ) \u00a4 Retrieves the table schema. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8319c50> The table for which schema you want to get required Exceptions: Type Description TableNotFound When the table is not found on HBase Returns: Type Description TableSchema TableSchema: The table schema Source code in hbase/client.py @_raise_for_table_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /schema\" ) def get_schema ( self , table : Path ( type = str )) -> TableSchema : \"\"\"Retrieves the table schema. Args: table (str): The table for which schema you want to get Raises: TableNotFound: When the table is not found on HBase Returns: TableSchema: The table schema \"\"\" get_software_version ( self ) \u00a4 Returns the software version Returns: Type Description Version Version: Version information about HBase Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"version\" ) def get_software_version ( self ) -> Version : \"\"\"Returns the software version Returns: Version: Version information about HBase \"\"\" get_storage_cluster_status ( self ) \u00a4 Returns detailed status on the HBase cluster backing the Stargate instance. Returns: Type Description StorageClusterStatus StorageClusterStatus: Detailed status on the HBase cluster backing the Stargate instance. Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"status/cluster\" ) def get_storage_cluster_status ( self ) -> StorageClusterStatus : \"\"\"Returns detailed status on the HBase cluster backing the Stargate instance. Returns: StorageClusterStatus: Detailed status on the HBase cluster backing the Stargate instance. \"\"\" get_storage_cluster_version ( self ) \u00a4 Returns version information regarding the HBase cluster backing the Stargate instance. Returns: Type Description StorageClusterVersion StorageClusterVersion: Version information regarding the HBase cluster backing the Stargate instance Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"version/cluster\" ) def get_storage_cluster_version ( self ) -> StorageClusterVersion : \"\"\"Returns version information regarding the HBase cluster backing the Stargate instance. Returns: StorageClusterVersion: Version information regarding the HBase cluster backing the Stargate instance \"\"\" get_table_metadata ( self , table ) \u00a4 Retrieves table region metadata Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8319e48> The table for which metadata you want to get required Exceptions: Type Description TableNotFound When the table is not found on HBase Returns: Type Description TableInfo TableInfo: The table region metadata Source code in hbase/client.py @_raise_for_table_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /regions\" ) def get_table_metadata ( self , table : Path ( type = str )) -> TableInfo : \"\"\"Retrieves table region metadata Args: table (str): The table for which metadata you want to get Raises: TableNotFound: When the table is not found on HBase Returns: TableInfo: The table region metadata \"\"\" get_tables ( self ) \u00a4 Retrieves the list of available tables Returns: Type Description TableList TableList: The list of available tables Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"\" ) def get_tables ( self ) -> TableList : \"\"\"Retrieves the list of available tables Returns: TableList: The list of available tables \"\"\" get_tables_in_namespace ( self , namespace ) \u00a4 Retrieves the list of available tables in the given namespace Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f8319a58> The given namespace. required Returns: Type Description TableList TableList: The list of available tables in the given namespace Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"namespaces/ {namespace} /tables\" ) def get_tables_in_namespace ( self , namespace : Path ( type = str )) -> TableList : \"\"\"Retrieves the list of available tables in the given namespace Args: namespace (str): The given namespace. Returns: TableList: The list of available tables in the given namespace \"\"\" insert_row ( self , table , row_id , column_data ) \u00a4 Utility function for inserting a single row into a table Parameters: Name Type Description Default table str The table for which you want to get the data from required row_id str The row ID for which you want to get the data from. Use * for multiple rows. required column_data Dict[str, str] The data for the row you wish to insert into the table required Returns: Type Description Response requests.models.Response: The HTTP response from inserting the row for the user to check Source code in hbase/client.py def insert_row ( self , table : str , row_id : str , column_data : Dict [ str , str ]) -> requests . models . Response : \"\"\"Utility function for inserting a single row into a table Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column_data (Dict[str, str]): The data for the row you wish to insert into the table Returns: requests.models.Response: The HTTP response from inserting the row for the user to check \"\"\" return self . insert_rows ( table , { row_id : column_data }) insert_rows ( self , table , rows ) \u00a4 Utility function for inserting multiple rows into a table Parameters: Name Type Description Default table str The table for which you want to get the data from required rows Dict[str, Dict[str, str]] The data for the row you wish to insert into the table, the keys should be the row id's required Returns: Type Description Response requests.models.Response: The HTTP response from inserting the rows for the user to check Source code in hbase/client.py def insert_rows ( self , table : str , rows : Dict [ str , Dict [ str , str ]]) -> requests . models . Response : \"\"\"Utility function for inserting multiple rows into a table Args: table (str): The table for which you want to get the data from rows (Dict[str, Dict[str, str]]): The data for the row you wish to insert into the table, the keys should be the row id's Returns: requests.models.Response: The HTTP response from inserting the rows for the user to check \"\"\" # TODO: Look into the column qualifier - dont think we want to hardcode? packet = { \"Row\" : [ { \"key\" : to_base64 ( row_id ), \"Cell\" : [{ \"column\" : to_base64 ( f \" { k } :e\" ), \"$\" : to_base64 ( v )} for k , v in row . items ()], } for row_id , row in rows . items () ] } return self . __insert_row ( table , data = json . dumps ( packet )) stateless_scanner ( self , table , row_prefix = '*' , start_row = None , end_row = None , columns = None , start_time = None , end_time = None , max_versions = None , batch_size = None , limit = None ) \u00a4 The current scanner API expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326a90> The table for which you want to get the data from required row_prefix <uplink.arguments.Path object at 0x7f52f8326ac8> The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to all rows (*). '*' start_row <uplink.arguments.Query object at 0x7f52f8326b00> The start row for the scan. Defaults to None. None end_row <uplink.arguments.Query object at 0x7f52f8326b38> The end row for the scan. Defaults to None. None columns <uplink.arguments.Query object at 0x7f52f8326b70> The columns to scan. Defaults to None. None start_time <uplink.arguments.Query object at 0x7f52f8326ba8> To only retrieve columns within a specific range of version timestamps. Defaults to None. None end_time <uplink.arguments.Query object at 0x7f52f8326be0> To only retrieve columns within a specific range of version timestamps. Defaults to None. None max_versions <uplink.arguments.Query object at 0x7f52f8326c18> To limit the number of versions of each column to be returned. Defaults to None. None batch_size <uplink.arguments.Query object at 0x7f52f8326c50> To limit the maximum number of values returned for each call to next().. Defaults to None. None limit <uplink.arguments.Query object at 0x7f52f8326c88> The number of rows to return in the scan operation.. Defaults to None. None Returns: Type Description CellSet CellSet: The data retrieved from HBase Notes More on start row, end row and limit parameters. If start row, end row and limit not specified, then the whole table will be scanned. If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. If only limit parameter is specified, then the scan operation will return N rows from the start of the table. If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_prefix} \" ) def stateless_scanner ( self , table : Path ( type = str ), row_prefix : Path ( type = str ) = \"*\" , start_row : Query ( \"startrow\" , type = str ) = None , # noqa: F821 end_row : Query ( \"endrow\" , type = str ) = None , # noqa: F821 columns : Query ( \"columns\" , type = List [ str ]) = None , # noqa: F821 start_time : Query ( \"starttime\" , type = int ) = None , # noqa: F821 end_time : Query ( \"endtime\" , type = int ) = None , # noqa: F821 max_versions : Query ( \"maxversions\" , type = int ) = None , # noqa: F821 batch_size : Query ( \"batchsize\" , type = int ) = None , # noqa: F821 limit : Query ( \"limit\" , type = int ) = None , # noqa: F821 ) -> CellSet : \"\"\"The current scanner API expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters. Args: table (str): The table for which you want to get the data from row_prefix (str, optional): The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to all rows (*). start_row (str, optional): The start row for the scan. Defaults to None. end_row (str, optional): The end row for the scan. Defaults to None. columns (List[str], optional): The columns to scan. Defaults to None. start_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. end_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. max_versions (int, optional): To limit the number of versions of each column to be returned. Defaults to None. batch_size (int, optional): To limit the maximum number of values returned for each call to next().. Defaults to None. limit (int, optional): The number of rows to return in the scan operation.. Defaults to None. Returns: CellSet: The data retrieved from HBase Notes: More on start row, end row and limit parameters. - If start row, end row and limit not specified, then the whole table will be scanned. - If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. - If only limit parameter is specified, then the scan operation will return N rows from the start of the table. - If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. - If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. \"\"\"","title":"client"},{"location":"reference/client/#hbase-hbase","text":"","title":"HBase - HBase"},{"location":"reference/client/#hbase.client.HBase","text":"A Python Client for the HBase API. Build using the following references: HBase REST API docs - 1.2 Notes Built to: Server='jetty/9.3.27.v20190418' Jersey='' OS='Linux 5.10.47-linuxkit amd64' REST='0.0.3' JVM='Oracle Corporation 1.8.0_302-25.302-b08' StorageClusterVersion='2.2.2'","title":"hbase.client.HBase"},{"location":"reference/client/#hbase.client.HBase.create_namespace","text":"Creates a namespace in HBase, this operation is idempotent Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f8326e80> (Type: string) The name of the namespace you want to create required Returns: Type Description Response requests.models.Response: The response for the user to handle and check the response code Source code in hbase/client.py @headers ({ \"Accept\" : \"application/json\" }) @post ( \"namespaces/ {namespace} \" ) def create_namespace ( self , namespace : Path ( type = str )) -> requests . models . Response : \"\"\"Creates a namespace in HBase, this operation is idempotent Args: namespace (str): (Type: string) The name of the namespace you want to create Returns: requests.models.Response: The response for the user to handle and check the response code \"\"\"","title":"create_namespace()"},{"location":"reference/client/#hbase.client.HBase.create_scanner","text":"Creates a scanner and returns the scanner id Parameters: Name Type Description Default table str The table for which you want to get the data from required row_prefix str The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to \"\". required start_row Optional[str] The start row for the scan. Defaults to None. None end_row Optional[str] The end row for the scan. Defaults to None. None columns List[str] The columns to scan. Defaults to None. [] batch_size Optional[int] To limit the maximum number of values returned for each call to next().. Defaults to None. None start_time Optional[int] To only retrieve columns within a specific range of version timestamps. Defaults to None. None end_time Optional[int] To only retrieve columns within a specific range of version timestamps. Defaults to None. None Exceptions: Type Description ScannerCreationFailed Raised when the scanner has failed to be created (request headers.Location is None) Returns: Type Description str str: The scanner ID Notes More on start row, end row and limit parameters. If start row, end row and limit not specified, then the whole table will be scanned. If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. If only limit parameter is specified, then the scan operation will return N rows from the start of the table. If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. Source code in hbase/client.py def create_scanner ( self , table : str , start_row : Optional [ str ] = None , end_row : Optional [ str ] = None , columns : List [ str ] = [], batch_size : Optional [ int ] = None , start_time : Optional [ int ] = None , end_time : Optional [ int ] = None , ) -> str : \"\"\"Creates a scanner and returns the scanner id Args: table (str): The table for which you want to get the data from row_prefix (str, optional): The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to \"\". start_row (str, optional): The start row for the scan. Defaults to None. end_row (str, optional): The end row for the scan. Defaults to None. columns (List[str], optional): The columns to scan. Defaults to None. batch_size (int, optional): To limit the maximum number of values returned for each call to next().. Defaults to None. start_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. end_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. Raises: ScannerCreationFailed: Raised when the scanner has failed to be created (request headers.Location is None) Returns: str: The scanner ID Notes: More on start row, end row and limit parameters. - If start row, end row and limit not specified, then the whole table will be scanned. - If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. - If only limit parameter is specified, then the scan operation will return N rows from the start of the table. - If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. - If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. \"\"\" add_if = lambda key , val : f ' { key } =\" { val } \" ' if val is not None else \"\" xml = f \"\"\"<Scanner { add_if ( \"batch\" , batch_size ) }{ add_if ( \"startRow\" , to_base64 ( start_row )) }{ add_if ( \"endRow\" , to_base64 ( end_row )) }{ add_if ( \"columns\" , to_base64 ( \",\" . join ( columns ))) }{ add_if ( \"startTime\" , start_time ) }{ add_if ( \"endTime\" , end_time ) } />\"\"\" resp = self . __create_scanner ( table , xml ) . headers . get ( \"Location\" ) if resp is None : raise ScannerCreationFailed ( \"Unable to create Scanner\" ) return resp . split ( \"/\" )[ - 1 ]","title":"create_scanner()"},{"location":"reference/client/#hbase.client.HBase.create_table","text":"Utility function for creating a table - HBase REST API only accepts XML for this request Parameters: Name Type Description Default table str The name of the table you wish to create required column_names List[str] The list of the table column names required Returns: Type Description Response requests.models.Response: The HTTP response from creating the table for the user to check Source code in hbase/client.py def create_table ( self , table : str , column_names : List [ str ]) -> requests . models . Response : \"\"\"Utility function for creating a table - HBase REST API only accepts XML for this request Args: table (str): The name of the table you wish to create column_names (List[str]): The list of the table column names Returns: requests.models.Response: The HTTP response from creating the table for the user to check \"\"\" xml_packet = f \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?><TableSchema name=\" { table } \"> { '' . join ( f '<ColumnSchema name=\" { col } \" />' for col in column_names ) } </TableSchema>\"\"\" return self . __create_table ( table , xml_packet )","title":"create_table()"},{"location":"reference/client/#hbase.client.HBase.delete_cell","text":"Deletes a entire cell from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832bac8> The name of the table from which the cell belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832ba90> The name of the row_id from which the cell belongs that you wish to delete. required column <uplink.arguments.Path object at 0x7f52f832bb70> The name of the column from which the cell belongs that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the cell for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} / {column} \" ) def delete_cell ( self , table : Path ( type = str ), row_id : Path ( type = str ), column : Path ( type = str ) ) -> requests . models . Response : \"\"\"Deletes a entire cell from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the cell belongs that you wish to delete. row_id (str): The name of the row_id from which the cell belongs that you wish to delete. column (str): The name of the column from which the cell belongs that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the cell for the user to check \"\"\"","title":"delete_cell()"},{"location":"reference/client/#hbase.client.HBase.delete_cell_with_timestamp","text":"Deletes a entire cell with the given timestamp from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832bd30> The name of the table from which the cell belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832bc88> The name of the row_id from which the cell belongs that you wish to delete. required column <uplink.arguments.Path object at 0x7f52f832bda0> The name of the column from which the cell belongs that you wish to delete. required timestamp <uplink.arguments.Path object at 0x7f52f832bcc0> The timestamp from which the cell belongs that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the cell for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} / {column} / {timestamp} \" ) def delete_cell_with_timestamp ( self , table : Path ( type = str ), row_id : Path ( type = str ), column : Path ( type = str ), timestamp : Path ( type = int ) ) -> requests . models . Response : \"\"\"Deletes a entire cell with the given timestamp from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the cell belongs that you wish to delete. row_id (str): The name of the row_id from which the cell belongs that you wish to delete. column (str): The name of the column from which the cell belongs that you wish to delete. timestamp (int): The timestamp from which the cell belongs that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the cell for the user to check \"\"\"","title":"delete_cell_with_timestamp()"},{"location":"reference/client/#hbase.client.HBase.delete_namespace","text":"Deletes a table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f832b7b8> The name of the namespace you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the namespace for the user to check Source code in hbase/client.py @delete ( \"namespaces/ {namespace} \" ) def delete_namespace ( self , namespace : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a table, if successful, returns HTTP 200 status. Args: namespace (str): The name of the namespace you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the namespace for the user to check \"\"\"","title":"delete_namespace()"},{"location":"reference/client/#hbase.client.HBase.delete_row","text":"Deletes a entire row from the table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832b940> The name of the table from which the row belongs that you wish to delete. required row_id <uplink.arguments.Path object at 0x7f52f832b978> The name of the row_id that you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the row for the user to check Source code in hbase/client.py @delete ( \" {table} / {row_id} \" ) def delete_row ( self , table : Path ( type = str ), row_id : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a entire row from the table, if successful, returns HTTP 200 status. Args: table (str): The name of the table from which the row belongs that you wish to delete. row_id (str): The name of the row_id that you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the row for the user to check \"\"\"","title":"delete_row()"},{"location":"reference/client/#hbase.client.HBase.delete_scanner","text":"Deletes resources associated with the scanner. Note: This is an optional action. Scanners will expire after some globally configurable interval has elapsed with no activity on the scanner. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832be80> The table name that the scanner is attached to. required scanner_id <uplink.arguments.Path object at 0x7f52f832bf98> The scanner id gathered from HBase.create_scanner(). required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the scanner for the user to check Source code in hbase/client.py @delete ( \" {table} /scanner/ {scanner_id} \" ) def delete_scanner ( self , table : Path ( type = str ), scanner_id : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes resources associated with the scanner. Note: This is an optional action. Scanners will expire after some globally configurable interval has elapsed with no activity on the scanner. Args: table (str): The table name that the scanner is attached to. scanner_id (str): The scanner id gathered from HBase.create_scanner(). Returns: requests.models.Response: The HTTP response from deleting the scanner for the user to check \"\"\"","title":"delete_scanner()"},{"location":"reference/client/#hbase.client.HBase.delete_table","text":"Deletes a table, if successful, returns HTTP 200 status. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f832b630> The name of the table you wish to delete. required Returns: Type Description Response requests.models.Response: The HTTP response from deleting the table for the user to check Source code in hbase/client.py @delete ( \" {table} /schema\" ) def delete_table ( self , table : Path ( type = str )) -> requests . models . Response : \"\"\"Deletes a table, if successful, returns HTTP 200 status. Args: table (str): The name of the table you wish to delete. Returns: requests.models.Response: The HTTP response from deleting the table for the user to check \"\"\"","title":"delete_table()"},{"location":"reference/client/#hbase.client.HBase.get_cell","text":"Retrieves single cell, use column={column_name}:{qualifier} for qualifiers Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f83262e8> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f8326320> The row ID for which you want to get the data from. Use * for multiple rows. required column <uplink.arguments.Path object at 0x7f52f8326358> The column name you want to get data from required num_versions <uplink.arguments.Query object at 0x7f52f8326390> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and column Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} / {column} \" ) def get_cell ( self , table : Path ( type = str ), # noqa: F821 row_id : Path ( type = str ), # noqa: F821 column : Path ( type = str ), # noqa: F821 num_versions : Query ( \"v\" , type = int ) = None , # noqa: F821 ) -> CellSet : # noqa: F821 \"\"\"Retrieves single cell, use column={column_name}:{qualifier} for qualifiers Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column (str): The column name you want to get data from num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and column Returns: CellSet: The data from the requested HBase Cell/s \"\"\"","title":"get_cell()"},{"location":"reference/client/#hbase.client.HBase.get_cell_with_timestamp","text":"Retrieves single cell with the given timestamp, use column={column_name}:{qualifier} for qualifiers Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f83265c0> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f83264e0> The row ID for which you want to get the data from. Use * for multiple rows. required column <uplink.arguments.Path object at 0x7f52f83265f8> The column name you want to get data from required timestamp <uplink.arguments.Path object at 0x7f52f8326630> The given timestamp to filter by required num_versions <uplink.arguments.Query object at 0x7f52f8326668> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and column Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} / {column} / {timestamp} \" ) def get_cell_with_timestamp ( self , table : Path ( type = str ), # noqa: F821 row_id : Path ( type = str ), # noqa: F821 column : Path ( type = str ), # noqa: F821 timestamp : Path ( type = int ), # noqa: F821 num_versions : Query ( \"v\" , type = int ) = None , # noqa: F821 ) -> CellSet : \"\"\"Retrieves single cell with the given timestamp, use column={column_name}:{qualifier} for qualifiers Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column (str): The column name you want to get data from timestamp (int): The given timestamp to filter by num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and column Returns: CellSet: The data from the requested HBase Cell/s \"\"\"","title":"get_cell_with_timestamp()"},{"location":"reference/client/#hbase.client.HBase.get_namespaces","text":"Lists all namespaces Returns: Type Description NameSpaces NameSpaces: All of the namespaces for the HBase instance Source code in hbase/client.py @returns . json ( NameSpaces ) @headers ({ \"Accept\" : \"application/json\" }) @get ( \"namespaces\" ) def get_namespaces ( self ) -> NameSpaces : \"\"\"Lists all namespaces Returns: NameSpaces: All of the namespaces for the HBase instance \"\"\"","title":"get_namespaces()"},{"location":"reference/client/#hbase.client.HBase.get_next_scanner","text":"Returns the values of the next cells found by the scanner, up to the configured batch amount. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326828> The table for which you want to get the data from required scanner_id <uplink.arguments.Path object at 0x7f52f8326898> The scanner id gathered from HBase.create_scanner() required Exceptions: Type Description ScannerCreationFailed If the scanner fails Returns: Type Description CellSet CellSet: The next round of data from the requested HBase Cell/s using the scanner Source code in hbase/client.py @_raise_for_scanner @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /scanner/ {scanner_id} \" ) def get_next_scanner ( self , table : Path ( type = str ), scanner_id : Path ( type = str )) -> CellSet : \"\"\"Returns the values of the next cells found by the scanner, up to the configured batch amount. Args: table (str): The table for which you want to get the data from scanner_id (str): The scanner id gathered from HBase.create_scanner() Raises: ScannerCreationFailed: If the scanner fails Returns: CellSet: The next round of data from the requested HBase Cell/s using the scanner \"\"\"","title":"get_next_scanner()"},{"location":"reference/client/#hbase.client.HBase.get_row","text":"Retrieves single row, or multiple rows using * Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326080> The table for which you want to get the data from required row_id <uplink.arguments.Path object at 0x7f52f83260b8> The row ID for which you want to get the data from. Use * for multiple rows. required num_versions <uplink.arguments.Query object at 0x7f52f83260f0> The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table and row_id Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_id} \" ) def get_row ( self , table : Path ( type = str ), row_id : Path ( type = str ), num_versions : Query ( \"v\" , type = int ) = None # noqa: F821 ) -> CellSet : # noqa: F821 \"\"\"Retrieves single row, or multiple rows using * Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. num_versions (int, optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table and row_id Returns: CellSet: The data from the requested HBase Cell/s \"\"\"","title":"get_row()"},{"location":"reference/client/#hbase.client.HBase.get_row_with_multiple_columns","text":"Retrieves one or more cells from a full row, or one or more specified columns in the row, with optional filtering via timestamp, and an optional restriction on the maximum number of versions to return. Parameters: Name Type Description Default table str The table for which you want to get the data from required row_id str The row ID for which you want to get the data from. Use * for multiple rows. required columns List[str] The column name you want to get data from. Defaults to []. [] start_time Optional[int] The given start timestamp to filter by. Defaults to None. None end_time Optional[int] The given end timestamp to filter by. Defaults to None. None num_versions Optional[int] The number of versions to return. Defaults to None. None Exceptions: Type Description NoDataFound If no data is found for the given table, row_id and filters Returns: Type Description CellSet CellSet: The data from the requested HBase Cell/s Source code in hbase/client.py def get_row_with_multiple_columns ( self , table : str , row_id : str , columns : List [ str ] = [], start_time : Optional [ int ] = None , end_time : Optional [ int ] = None , num_versions : Optional [ int ] = None , ) -> CellSet : \"\"\"Retrieves one or more cells from a full row, or one or more specified columns in the row, with optional filtering via timestamp, and an optional restriction on the maximum number of versions to return. Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. columns (List[str], optional): The column name you want to get data from. Defaults to []. start_time (Optional[int], optional): The given start timestamp to filter by. Defaults to None. end_time (Optional[int], optional): The given end timestamp to filter by. Defaults to None. num_versions (Optional[int], optional): The number of versions to return. Defaults to None. Raises: NoDataFound: If no data is found for the given table, row_id and filters Returns: CellSet: The data from the requested HBase Cell/s \"\"\" return self . stateless_scanner ( table , row_prefix = row_id , columns = columns , start_time = start_time , end_time = end_time , max_versions = num_versions , )","title":"get_row_with_multiple_columns()"},{"location":"reference/client/#hbase.client.HBase.get_schema","text":"Retrieves the table schema. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8319c50> The table for which schema you want to get required Exceptions: Type Description TableNotFound When the table is not found on HBase Returns: Type Description TableSchema TableSchema: The table schema Source code in hbase/client.py @_raise_for_table_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /schema\" ) def get_schema ( self , table : Path ( type = str )) -> TableSchema : \"\"\"Retrieves the table schema. Args: table (str): The table for which schema you want to get Raises: TableNotFound: When the table is not found on HBase Returns: TableSchema: The table schema \"\"\"","title":"get_schema()"},{"location":"reference/client/#hbase.client.HBase.get_software_version","text":"Returns the software version Returns: Type Description Version Version: Version information about HBase Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"version\" ) def get_software_version ( self ) -> Version : \"\"\"Returns the software version Returns: Version: Version information about HBase \"\"\"","title":"get_software_version()"},{"location":"reference/client/#hbase.client.HBase.get_storage_cluster_status","text":"Returns detailed status on the HBase cluster backing the Stargate instance. Returns: Type Description StorageClusterStatus StorageClusterStatus: Detailed status on the HBase cluster backing the Stargate instance. Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"status/cluster\" ) def get_storage_cluster_status ( self ) -> StorageClusterStatus : \"\"\"Returns detailed status on the HBase cluster backing the Stargate instance. Returns: StorageClusterStatus: Detailed status on the HBase cluster backing the Stargate instance. \"\"\"","title":"get_storage_cluster_status()"},{"location":"reference/client/#hbase.client.HBase.get_storage_cluster_version","text":"Returns version information regarding the HBase cluster backing the Stargate instance. Returns: Type Description StorageClusterVersion StorageClusterVersion: Version information regarding the HBase cluster backing the Stargate instance Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"version/cluster\" ) def get_storage_cluster_version ( self ) -> StorageClusterVersion : \"\"\"Returns version information regarding the HBase cluster backing the Stargate instance. Returns: StorageClusterVersion: Version information regarding the HBase cluster backing the Stargate instance \"\"\"","title":"get_storage_cluster_version()"},{"location":"reference/client/#hbase.client.HBase.get_table_metadata","text":"Retrieves table region metadata Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8319e48> The table for which metadata you want to get required Exceptions: Type Description TableNotFound When the table is not found on HBase Returns: Type Description TableInfo TableInfo: The table region metadata Source code in hbase/client.py @_raise_for_table_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} /regions\" ) def get_table_metadata ( self , table : Path ( type = str )) -> TableInfo : \"\"\"Retrieves table region metadata Args: table (str): The table for which metadata you want to get Raises: TableNotFound: When the table is not found on HBase Returns: TableInfo: The table region metadata \"\"\"","title":"get_table_metadata()"},{"location":"reference/client/#hbase.client.HBase.get_tables","text":"Retrieves the list of available tables Returns: Type Description TableList TableList: The list of available tables Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"\" ) def get_tables ( self ) -> TableList : \"\"\"Retrieves the list of available tables Returns: TableList: The list of available tables \"\"\"","title":"get_tables()"},{"location":"reference/client/#hbase.client.HBase.get_tables_in_namespace","text":"Retrieves the list of available tables in the given namespace Parameters: Name Type Description Default namespace <uplink.arguments.Path object at 0x7f52f8319a58> The given namespace. required Returns: Type Description TableList TableList: The list of available tables in the given namespace Source code in hbase/client.py @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \"namespaces/ {namespace} /tables\" ) def get_tables_in_namespace ( self , namespace : Path ( type = str )) -> TableList : \"\"\"Retrieves the list of available tables in the given namespace Args: namespace (str): The given namespace. Returns: TableList: The list of available tables in the given namespace \"\"\"","title":"get_tables_in_namespace()"},{"location":"reference/client/#hbase.client.HBase.insert_row","text":"Utility function for inserting a single row into a table Parameters: Name Type Description Default table str The table for which you want to get the data from required row_id str The row ID for which you want to get the data from. Use * for multiple rows. required column_data Dict[str, str] The data for the row you wish to insert into the table required Returns: Type Description Response requests.models.Response: The HTTP response from inserting the row for the user to check Source code in hbase/client.py def insert_row ( self , table : str , row_id : str , column_data : Dict [ str , str ]) -> requests . models . Response : \"\"\"Utility function for inserting a single row into a table Args: table (str): The table for which you want to get the data from row_id (str): The row ID for which you want to get the data from. Use * for multiple rows. column_data (Dict[str, str]): The data for the row you wish to insert into the table Returns: requests.models.Response: The HTTP response from inserting the row for the user to check \"\"\" return self . insert_rows ( table , { row_id : column_data })","title":"insert_row()"},{"location":"reference/client/#hbase.client.HBase.insert_rows","text":"Utility function for inserting multiple rows into a table Parameters: Name Type Description Default table str The table for which you want to get the data from required rows Dict[str, Dict[str, str]] The data for the row you wish to insert into the table, the keys should be the row id's required Returns: Type Description Response requests.models.Response: The HTTP response from inserting the rows for the user to check Source code in hbase/client.py def insert_rows ( self , table : str , rows : Dict [ str , Dict [ str , str ]]) -> requests . models . Response : \"\"\"Utility function for inserting multiple rows into a table Args: table (str): The table for which you want to get the data from rows (Dict[str, Dict[str, str]]): The data for the row you wish to insert into the table, the keys should be the row id's Returns: requests.models.Response: The HTTP response from inserting the rows for the user to check \"\"\" # TODO: Look into the column qualifier - dont think we want to hardcode? packet = { \"Row\" : [ { \"key\" : to_base64 ( row_id ), \"Cell\" : [{ \"column\" : to_base64 ( f \" { k } :e\" ), \"$\" : to_base64 ( v )} for k , v in row . items ()], } for row_id , row in rows . items () ] } return self . __insert_row ( table , data = json . dumps ( packet ))","title":"insert_rows()"},{"location":"reference/client/#hbase.client.HBase.stateless_scanner","text":"The current scanner API expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters. Parameters: Name Type Description Default table <uplink.arguments.Path object at 0x7f52f8326a90> The table for which you want to get the data from required row_prefix <uplink.arguments.Path object at 0x7f52f8326ac8> The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to all rows (*). '*' start_row <uplink.arguments.Query object at 0x7f52f8326b00> The start row for the scan. Defaults to None. None end_row <uplink.arguments.Query object at 0x7f52f8326b38> The end row for the scan. Defaults to None. None columns <uplink.arguments.Query object at 0x7f52f8326b70> The columns to scan. Defaults to None. None start_time <uplink.arguments.Query object at 0x7f52f8326ba8> To only retrieve columns within a specific range of version timestamps. Defaults to None. None end_time <uplink.arguments.Query object at 0x7f52f8326be0> To only retrieve columns within a specific range of version timestamps. Defaults to None. None max_versions <uplink.arguments.Query object at 0x7f52f8326c18> To limit the number of versions of each column to be returned. Defaults to None. None batch_size <uplink.arguments.Query object at 0x7f52f8326c50> To limit the maximum number of values returned for each call to next().. Defaults to None. None limit <uplink.arguments.Query object at 0x7f52f8326c88> The number of rows to return in the scan operation.. Defaults to None. None Returns: Type Description CellSet CellSet: The data retrieved from HBase Notes More on start row, end row and limit parameters. If start row, end row and limit not specified, then the whole table will be scanned. If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. If only limit parameter is specified, then the scan operation will return N rows from the start of the table. If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. Source code in hbase/client.py @_raise_for_data_not_found @returns . json @headers ({ \"Accept\" : \"application/json\" }) @get ( \" {table} / {row_prefix} \" ) def stateless_scanner ( self , table : Path ( type = str ), row_prefix : Path ( type = str ) = \"*\" , start_row : Query ( \"startrow\" , type = str ) = None , # noqa: F821 end_row : Query ( \"endrow\" , type = str ) = None , # noqa: F821 columns : Query ( \"columns\" , type = List [ str ]) = None , # noqa: F821 start_time : Query ( \"starttime\" , type = int ) = None , # noqa: F821 end_time : Query ( \"endtime\" , type = int ) = None , # noqa: F821 max_versions : Query ( \"maxversions\" , type = int ) = None , # noqa: F821 batch_size : Query ( \"batchsize\" , type = int ) = None , # noqa: F821 limit : Query ( \"limit\" , type = int ) = None , # noqa: F821 ) -> CellSet : \"\"\"The current scanner API expects clients to restart scans if there is a REST server failure in the midst. The stateless does not store any state related to scan operation and all the parameters are specified as query parameters. Args: table (str): The table for which you want to get the data from row_prefix (str, optional): The row ID for which you want to get the data from. Use * for multiple rows.. Defaults to all rows (*). start_row (str, optional): The start row for the scan. Defaults to None. end_row (str, optional): The end row for the scan. Defaults to None. columns (List[str], optional): The columns to scan. Defaults to None. start_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. end_time (int, optional): To only retrieve columns within a specific range of version timestamps. Defaults to None. max_versions (int, optional): To limit the number of versions of each column to be returned. Defaults to None. batch_size (int, optional): To limit the maximum number of values returned for each call to next().. Defaults to None. limit (int, optional): The number of rows to return in the scan operation.. Defaults to None. Returns: CellSet: The data retrieved from HBase Notes: More on start row, end row and limit parameters. - If start row, end row and limit not specified, then the whole table will be scanned. - If start row and limit (say N) is specified, then the scan operation will return N rows from the start row specified. - If only limit parameter is specified, then the scan operation will return N rows from the start of the table. - If limit and end row are specified, then the scan operation will return N rows from start of table till the end row. If the end row is reached before N rows ( say M and M < N ), then M rows will be returned to the user. - If start row, end row and limit (say N ) are specified and N < number of rows between start row and end row, then N rows from start row will be returned to the user. If N > (number of rows between start row and end row (say M), then M number of rows will be returned to the user. \"\"\"","title":"stateless_scanner()"},{"location":"reference/errors/","text":"HBase - Errors \u00a4 \u00a4 NoDataFound \u00a4 Raised when there is no data to retrive (Status Code: 404) ScannerCreationFailed \u00a4 Raised when the scanner has failed to be created (request headers.Location is None) ScannerExhausted \u00a4 Raised when the scanner is exhausted (Status Code: 204) ScannerInvalid \u00a4 Raised when the scannerID is invalid (Status Code: 404) TableNotFound \u00a4 Raised when there is no table found (Status Code: 404)","title":"errors"},{"location":"reference/errors/#hbase-errors","text":"","title":"HBase - Errors"},{"location":"reference/errors/#hbase.errors","text":"","title":"hbase.errors"},{"location":"reference/errors/#hbase.errors.NoDataFound","text":"Raised when there is no data to retrive (Status Code: 404)","title":"NoDataFound"},{"location":"reference/errors/#hbase.errors.ScannerCreationFailed","text":"Raised when the scanner has failed to be created (request headers.Location is None)","title":"ScannerCreationFailed"},{"location":"reference/errors/#hbase.errors.ScannerExhausted","text":"Raised when the scanner is exhausted (Status Code: 204)","title":"ScannerExhausted"},{"location":"reference/errors/#hbase.errors.ScannerInvalid","text":"Raised when the scannerID is invalid (Status Code: 404)","title":"ScannerInvalid"},{"location":"reference/errors/#hbase.errors.TableNotFound","text":"Raised when there is no table found (Status Code: 404)","title":"TableNotFound"},{"location":"reference/models/cell_set/","text":"HBase - Models \u00a4 \u00a4 Cell pydantic-model \u00a4 column: str pydantic-field required \u00a4 timestamp: int pydantic-field \u00a4 value: str pydantic-field required \u00a4 CellSet pydantic-model \u00a4 Row: Row pydantic-field required \u00a4 Row pydantic-model \u00a4 Cell: Cell pydantic-field required \u00a4 key: str pydantic-field required \u00a4","title":"cell_set"},{"location":"reference/models/cell_set/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/cell_set/#hbase.models.cell_set","text":"","title":"hbase.models.cell_set"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Cell","text":"","title":"Cell"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Cell.column","text":"","title":"column"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Cell.timestamp","text":"","title":"timestamp"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Cell.value","text":"","title":"value"},{"location":"reference/models/cell_set/#hbase.models.cell_set.CellSet","text":"","title":"CellSet"},{"location":"reference/models/cell_set/#hbase.models.cell_set.CellSet.Row","text":"","title":"Row"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Row","text":"","title":"Row"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Row.Cell","text":"","title":"Cell"},{"location":"reference/models/cell_set/#hbase.models.cell_set.Row.key","text":"","title":"key"},{"location":"reference/models/namespaces/","text":"HBase - Models \u00a4 \u00a4 NameSpaces pydantic-model \u00a4 Namespace: str pydantic-field required \u00a4","title":"namespaces"},{"location":"reference/models/namespaces/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/namespaces/#hbase.models.namespaces","text":"","title":"hbase.models.namespaces"},{"location":"reference/models/namespaces/#hbase.models.namespaces.NameSpaces","text":"","title":"NameSpaces"},{"location":"reference/models/namespaces/#hbase.models.namespaces.NameSpaces.Namespace","text":"","title":"Namespace"},{"location":"reference/models/storage_cluster_status/","text":"HBase - Models \u00a4 \u00a4 LiveNode pydantic-model \u00a4 heapSizeMB: int pydantic-field \u00a4 maxHeapSizeMB: int pydantic-field \u00a4 name: str pydantic-field required \u00a4 Region: Region pydantic-field required \u00a4 requests: int pydantic-field \u00a4 startCode: int pydantic-field \u00a4 Region pydantic-model \u00a4 currentCompactedKVs: int pydantic-field \u00a4 memstoreSizeMB: int pydantic-field \u00a4 name: str pydantic-field required \u00a4 readRequestsCount: int pydantic-field \u00a4 rootIndexSizeKB: int pydantic-field \u00a4 storefileIndexSizeKB: int pydantic-field \u00a4 storefiles: int pydantic-field \u00a4 storefileSizeMB: int pydantic-field \u00a4 stores: int pydantic-field \u00a4 totalCompactingKVs: int pydantic-field \u00a4 totalStaticBloomSizeKB: int pydantic-field \u00a4 totalStaticIndexSizeKB: int pydantic-field \u00a4 writeRequestsCount: int pydantic-field \u00a4 StorageClusterStatus pydantic-model \u00a4 averageLoad: float pydantic-field \u00a4 DeadNodes: str pydantic-field required \u00a4 LiveNodes: LiveNode pydantic-field required \u00a4 regions: int pydantic-field \u00a4 requests: int pydantic-field \u00a4","title":"storage_cluster_status"},{"location":"reference/models/storage_cluster_status/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status","text":"","title":"hbase.models.storage_cluster_status"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode","text":"","title":"LiveNode"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.heapSizeMB","text":"","title":"heapSizeMB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.maxHeapSizeMB","text":"","title":"maxHeapSizeMB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.name","text":"","title":"name"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.Region","text":"","title":"Region"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.requests","text":"","title":"requests"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.LiveNode.startCode","text":"","title":"startCode"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region","text":"","title":"Region"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.currentCompactedKVs","text":"","title":"currentCompactedKVs"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.memstoreSizeMB","text":"","title":"memstoreSizeMB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.name","text":"","title":"name"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.readRequestsCount","text":"","title":"readRequestsCount"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.rootIndexSizeKB","text":"","title":"rootIndexSizeKB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.storefileIndexSizeKB","text":"","title":"storefileIndexSizeKB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.storefiles","text":"","title":"storefiles"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.storefileSizeMB","text":"","title":"storefileSizeMB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.stores","text":"","title":"stores"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.totalCompactingKVs","text":"","title":"totalCompactingKVs"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.totalStaticBloomSizeKB","text":"","title":"totalStaticBloomSizeKB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.totalStaticIndexSizeKB","text":"","title":"totalStaticIndexSizeKB"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.Region.writeRequestsCount","text":"","title":"writeRequestsCount"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus","text":"","title":"StorageClusterStatus"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus.averageLoad","text":"","title":"averageLoad"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus.DeadNodes","text":"","title":"DeadNodes"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus.LiveNodes","text":"","title":"LiveNodes"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus.regions","text":"","title":"regions"},{"location":"reference/models/storage_cluster_status/#hbase.models.storage_cluster_status.StorageClusterStatus.requests","text":"","title":"requests"},{"location":"reference/models/table_info/","text":"HBase - Models \u00a4 \u00a4 Region pydantic-model \u00a4 endKey: str pydantic-field \u00a4 id: int pydantic-field \u00a4 location: str pydantic-field \u00a4 name: str pydantic-field required \u00a4 startKey: str pydantic-field \u00a4 TableInfo pydantic-model \u00a4 name: str pydantic-field required \u00a4 Region: Region pydantic-field required \u00a4","title":"table_info"},{"location":"reference/models/table_info/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/table_info/#hbase.models.table_info","text":"","title":"hbase.models.table_info"},{"location":"reference/models/table_info/#hbase.models.table_info.Region","text":"","title":"Region"},{"location":"reference/models/table_info/#hbase.models.table_info.Region.endKey","text":"","title":"endKey"},{"location":"reference/models/table_info/#hbase.models.table_info.Region.id","text":"","title":"id"},{"location":"reference/models/table_info/#hbase.models.table_info.Region.location","text":"","title":"location"},{"location":"reference/models/table_info/#hbase.models.table_info.Region.name","text":"","title":"name"},{"location":"reference/models/table_info/#hbase.models.table_info.Region.startKey","text":"","title":"startKey"},{"location":"reference/models/table_info/#hbase.models.table_info.TableInfo","text":"","title":"TableInfo"},{"location":"reference/models/table_info/#hbase.models.table_info.TableInfo.name","text":"","title":"name"},{"location":"reference/models/table_info/#hbase.models.table_info.TableInfo.Region","text":"","title":"Region"},{"location":"reference/models/table_list/","text":"HBase - Models \u00a4 \u00a4 TableList pydantic-model \u00a4 table: TableListItem pydantic-field required \u00a4 TableListItem pydantic-model \u00a4 name: str pydantic-field required \u00a4","title":"table_list"},{"location":"reference/models/table_list/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/table_list/#hbase.models.table_list","text":"","title":"hbase.models.table_list"},{"location":"reference/models/table_list/#hbase.models.table_list.TableList","text":"","title":"TableList"},{"location":"reference/models/table_list/#hbase.models.table_list.TableList.table","text":"","title":"table"},{"location":"reference/models/table_list/#hbase.models.table_list.TableListItem","text":"","title":"TableListItem"},{"location":"reference/models/table_list/#hbase.models.table_list.TableListItem.name","text":"","title":"name"},{"location":"reference/models/table_schema/","text":"HBase - Models \u00a4 \u00a4 Attribute pydantic-model \u00a4 name: str pydantic-field required \u00a4 value: str pydantic-field required \u00a4 ColumnSchema pydantic-model \u00a4 BLOCKSIZE: int pydantic-field \u00a4 BLOOMFILTER: str pydantic-field \u00a4 CACHE_BLOOMS_ON_WRITE: bool pydantic-field \u00a4 CACHE_DATA_ON_WRITE: bool pydantic-field \u00a4 CACHE_INDEX_ON_WRITE: bool pydantic-field \u00a4 COMPRESSION: str pydantic-field \u00a4 DATA_BLOCK_ENCODING: str pydantic-field \u00a4 EVICT_BLOCKS_ON_CLOSE: bool pydantic-field \u00a4 IN_MEMORY: bool pydantic-field \u00a4 KEEP_DELETED_CELLS: bool pydantic-field \u00a4 LOCKCACHE: bool pydantic-field \u00a4 MIN_VERSIONS: int pydantic-field \u00a4 name: str pydantic-field \u00a4 NEW_VERSION_BEHAVIOR: bool pydantic-field \u00a4 PREFETCH_BLOCKS_ON_OPEN: bool pydantic-field \u00a4 REPLICATION_SCOPE: int pydantic-field \u00a4 TTL: int pydantic-field \u00a4 VERSIONS: int pydantic-field \u00a4 TableSchema pydantic-model \u00a4 ColumnSchema: ColumnSchema pydantic-field required \u00a4 IS_META: bool pydantic-field \u00a4 name: str pydantic-field \u00a4","title":"table_schema"},{"location":"reference/models/table_schema/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/table_schema/#hbase.models.table_schema","text":"","title":"hbase.models.table_schema"},{"location":"reference/models/table_schema/#hbase.models.table_schema.Attribute","text":"","title":"Attribute"},{"location":"reference/models/table_schema/#hbase.models.table_schema.Attribute.name","text":"","title":"name"},{"location":"reference/models/table_schema/#hbase.models.table_schema.Attribute.value","text":"","title":"value"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema","text":"","title":"ColumnSchema"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.BLOCKSIZE","text":"","title":"BLOCKSIZE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.BLOOMFILTER","text":"","title":"BLOOMFILTER"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.CACHE_BLOOMS_ON_WRITE","text":"","title":"CACHE_BLOOMS_ON_WRITE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.CACHE_DATA_ON_WRITE","text":"","title":"CACHE_DATA_ON_WRITE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.CACHE_INDEX_ON_WRITE","text":"","title":"CACHE_INDEX_ON_WRITE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.COMPRESSION","text":"","title":"COMPRESSION"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.DATA_BLOCK_ENCODING","text":"","title":"DATA_BLOCK_ENCODING"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.EVICT_BLOCKS_ON_CLOSE","text":"","title":"EVICT_BLOCKS_ON_CLOSE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.IN_MEMORY","text":"","title":"IN_MEMORY"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.KEEP_DELETED_CELLS","text":"","title":"KEEP_DELETED_CELLS"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.LOCKCACHE","text":"","title":"LOCKCACHE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.MIN_VERSIONS","text":"","title":"MIN_VERSIONS"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.name","text":"","title":"name"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.NEW_VERSION_BEHAVIOR","text":"","title":"NEW_VERSION_BEHAVIOR"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.PREFETCH_BLOCKS_ON_OPEN","text":"","title":"PREFETCH_BLOCKS_ON_OPEN"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.REPLICATION_SCOPE","text":"","title":"REPLICATION_SCOPE"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.TTL","text":"","title":"TTL"},{"location":"reference/models/table_schema/#hbase.models.table_schema.ColumnSchema.VERSIONS","text":"","title":"VERSIONS"},{"location":"reference/models/table_schema/#hbase.models.table_schema.TableSchema","text":"","title":"TableSchema"},{"location":"reference/models/table_schema/#hbase.models.table_schema.TableSchema.ColumnSchema","text":"","title":"ColumnSchema"},{"location":"reference/models/table_schema/#hbase.models.table_schema.TableSchema.IS_META","text":"","title":"IS_META"},{"location":"reference/models/table_schema/#hbase.models.table_schema.TableSchema.name","text":"","title":"name"},{"location":"reference/models/version/","text":"HBase - Models \u00a4 \u00a4 StorageClusterVersion pydantic-model \u00a4 Version: str pydantic-field \u00a4 Version pydantic-model \u00a4 Jersey: str pydantic-field \u00a4 JVM: str pydantic-field \u00a4 OS: str pydantic-field \u00a4 REST: str pydantic-field \u00a4 Server: str pydantic-field \u00a4","title":"version"},{"location":"reference/models/version/#hbase-models","text":"","title":"HBase - Models"},{"location":"reference/models/version/#hbase.models.version","text":"","title":"hbase.models.version"},{"location":"reference/models/version/#hbase.models.version.StorageClusterVersion","text":"","title":"StorageClusterVersion"},{"location":"reference/models/version/#hbase.models.version.StorageClusterVersion.Version","text":"","title":"Version"},{"location":"reference/models/version/#hbase.models.version.Version","text":"","title":"Version"},{"location":"reference/models/version/#hbase.models.version.Version.Jersey","text":"","title":"Jersey"},{"location":"reference/models/version/#hbase.models.version.Version.JVM","text":"","title":"JVM"},{"location":"reference/models/version/#hbase.models.version.Version.OS","text":"","title":"OS"},{"location":"reference/models/version/#hbase.models.version.Version.REST","text":"","title":"REST"},{"location":"reference/models/version/#hbase.models.version.Version.Server","text":"","title":"Server"},{"location":"user-guide/first-steps/","text":"Coming soon ... \u00a4","title":"First steps"},{"location":"user-guide/first-steps/#coming-soon","text":"","title":"Coming soon ..."},{"location":"user-guide/intro/","text":"Coming soon ... \u00a4","title":"Intro"},{"location":"user-guide/intro/#coming-soon","text":"","title":"Coming soon ..."}]}